<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic USD Payloads with Babylon.js</title>
    <style>
        body { margin: 0; font-family: Arial, sans-serif; }
        #controls { padding: 10px; background-color: #f0f0f0; }
        #renderCanvas { width: 100%; height: 500px; display: block; }
        #extrasData { padding: 20px; background-color: #f0f0f0; margin-top: 10px; max-height: 300px; overflow-y: auto; }
    </style>
</head>
<body>
    <div id="controls">
        <div>
            <label>Select USD Scene: </label>
            <select id="sceneSelector">
                <option value="">Loading scenes...</option>
            </select>
            <button onclick="loadSelectedScene()">Load Scene</button>
        </div>
        <br>
        <div>
            <strong>Note:</strong> USD files are converted to glTF and stored in Assets/ folder, then loaded into Babylon.js
        </div>
    </div>
    <canvas id="renderCanvas"></canvas>
    <div id="extrasData" style="padding: 20px; background-color: #f0f0f0; margin-top: 10px; max-height: 300px; overflow-y: auto;">
        <h3>glTF Extras Data:</h3>
        <p>Load a scene to see extras data here...</p>
    </div>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script>
        const canvas = document.getElementById('renderCanvas');
        const engine = new BABYLON.Engine(canvas, true);
        let scene;

        // Initialize scene and load available USD files
        async function createScene() {
            scene = new BABYLON.Scene(engine);
            const camera = new BABYLON.ArcRotateCamera("Camera", Math.PI / 2, Math.PI / 2.5, 10, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

            // Load available scenes for dropdown
            await loadAvailableScenes();

            return scene;
        }

        // Load available USD scenes from server
        async function loadAvailableScenes() {
            try {
                const response = await fetch('http://localhost:3000/scenes');
                const data = await response.json();
                
                const selector = document.getElementById('sceneSelector');
                selector.innerHTML = '';
                
                if (data.success && data.files.length > 0) {
                    data.files.forEach(file => {
                        const option = document.createElement('option');
                        option.value = file;
                        option.textContent = file;
                        selector.appendChild(option);
                    });
                } else {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = 'No USD files found';
                    selector.appendChild(option);
                }
            } catch (error) {
                console.error('Error loading available scenes:', error);
                const selector = document.getElementById('sceneSelector');
                selector.innerHTML = '<option value="">Error loading scenes</option>';
            }
        }

        // Load selected scene
        async function loadSelectedScene() {
            const selector = document.getElementById('sceneSelector');
            const selectedFile = selector.value;
            
            if (!selectedFile) {
                alert('Please select a USD file to load');
                return;
            }
            
            try {
                console.log(`Loading scene: ${selectedFile}`);
                
                // Clear existing scene content (keep camera and lights)
                scene.meshes.slice().forEach(mesh => {
                    if (mesh.name !== 'camera' && !mesh.name.includes('light')) {
                        mesh.dispose();
                    }
                });
                
                // Convert USD file to glTF (text format)
                const gltfFilename = selectedFile.replace(/\.(usda|usd)$/, '.gltf');
                console.log(`Converting ${selectedFile} to ${gltfFilename}`);
                
                const convertResponse = await fetch(`http://localhost:3000/convert/gltf?input=${selectedFile}&output=${gltfFilename}`);
                const convertData = await convertResponse.json();
                
                if (!convertData.success) {
                    throw new Error(convertData.error || 'Conversion failed');
                }
                
                console.log(`Conversion successful: ${convertData.outputPath}`);
                
                // Load the converted glTF file (using the filename from server response)
                const actualFilename = convertData.outputPath.split('/').pop();
                await loadGltfWithExtras(`http://localhost:3000/Scenes/Assets/`, actualFilename);
                
            } catch (error) {
                console.error('Error loading scene:', error);
                alert(`Error loading scene: ${error.message}`);
            }
        }

        // Load glTF and display extras data
        async function loadGltfWithExtras(rootUrl, sceneFilename) {
            console.log(`Loading glTF file: ${rootUrl}${sceneFilename}`);
            
            // First, let's fetch the glTF file directly to see what's in it
            try {
                const gltfUrl = `${rootUrl}${sceneFilename}`;
                console.log(`Fetching glTF content from: ${gltfUrl}`);
                
                const response = await fetch(gltfUrl);
                const gltfContent = await response.json();
                
                console.log('=== Raw glTF Content ===');
                console.log('glTF nodes:', gltfContent.nodes);
                
                if (gltfContent.nodes) {
                    gltfContent.nodes.forEach((node, index) => {
                        console.log(`Node ${index} (${node.name || 'unnamed'}):`, node);
                        if (node.extras) {
                            console.log(`  -> Node ${index} has extras:`, node.extras);
                        }
                    });
                }
                
                console.log('=== End Raw glTF Content ===');
                
            } catch (fetchError) {
                console.warn('Could not fetch glTF content directly:', fetchError);
            }
            
            return new Promise((resolve, reject) => {
                BABYLON.SceneLoader.ImportMesh("", rootUrl, sceneFilename, scene, (meshes, particleSystems, skeletons, animationGroups, transformNodes) => {
                    console.log(`Successfully loaded glTF: ${sceneFilename}`);
                    console.log(`Loaded ${meshes.length} meshes:`, meshes.map(m => m.name));
                    console.log(`Loaded ${transformNodes.length} transform nodes:`, transformNodes.map(n => n.name));
                    
                    // Display extras data from both meshes and nodes
                    displayExtrasData(meshes, transformNodes);
                    
                    resolve({ meshes, particleSystems, skeletons, animationGroups, transformNodes });
                }, null, (scene, message, exception) => {
                    console.error(`Error loading ${sceneFilename}:`, message, exception);
                    reject(new Error(message));
                });
            });
        }

        // Display extras data from loaded glTF meshes and nodes
        function displayExtrasData(meshes, transformNodes = []) {
            const extrasContainer = document.getElementById('extrasData');
            extrasContainer.innerHTML = '<h3>glTF Extras Data:</h3>';
            
            let foundExtras = false;
            
            // Check all nodes (including transform nodes) for extras data
            const allNodes = [...transformNodes];
            
            // Also add any mesh nodes that have parent information
            meshes.forEach(mesh => {
                if (mesh.parent && !allNodes.includes(mesh.parent)) {
                    allNodes.push(mesh.parent);
                }
                allNodes.push(mesh);
            });
            
            console.log(`=== Checking ${allNodes.length} nodes for extras data ===`);
            
            allNodes.forEach((node, index) => {
                console.log(`=== Node ${index}: ${node.name || 'Unnamed'} (${node.constructor.name}) ===`);
                console.log('Full node metadata:', node.metadata);
                
                // Check multiple possible locations for extras data
                let extrasData = null;
                let extrasSource = '';
                
                // Check various possible paths where Babylon.js might store glTF extras
                if (node.metadata && node.metadata.gltf && node.metadata.gltf.extras) {
                    extrasData = node.metadata.gltf.extras;
                    extrasSource = 'metadata.gltf.extras';
                } else if (node.metadata && node.metadata.extras) {
                    extrasData = node.metadata.extras;
                    extrasSource = 'metadata.extras';
                } else if (node.metadata && node.metadata.customData) {
                    extrasData = node.metadata.customData;
                    extrasSource = 'metadata.customData';
                } else if (node.metadata && node.metadata._gltf && node.metadata._gltf.extras) {
                    extrasData = node.metadata._gltf.extras;
                    extrasSource = 'metadata._gltf.extras';
                } else if (node.extras) {
                    extrasData = node.extras;
                    extrasSource = 'node.extras';
                }
                
                if (extrasData) {
                    foundExtras = true;
                    const extrasDiv = document.createElement('div');
                    extrasDiv.style.marginBottom = '10px';
                    extrasDiv.style.padding = '10px';
                    extrasDiv.style.border = '1px solid #ccc';
                    extrasDiv.style.backgroundColor = '#f9f9f9';
                    
                    extrasDiv.innerHTML = `
                        <h4>${node.constructor.name}: ${node.name || `Node ${index}`}</h4>
                        <p><strong>Source:</strong> ${extrasSource}</p>
                        <pre>${JSON.stringify(extrasData, null, 2)}</pre>
                    `;
                    
                    extrasContainer.appendChild(extrasDiv);
                    console.log(`Extras found for ${node.name} at ${extrasSource}:`, extrasData);
                } else {
                    console.log(`No extras data found for node ${node.name || `Node ${index}`}`);
                }
            });
            
            // Also check if we can access the raw glTF data from the scene
            console.log('=== Scene-level data check ===');
            if (scene.metadata) {
                console.log('Scene metadata:', scene.metadata);
                if (scene.metadata.gltf) {
                    console.log('Scene glTF data:', scene.metadata.gltf);
                }
            }
            
            if (!foundExtras) {
                extrasContainer.innerHTML += '<p>No extras data found in the loaded glTF file.</p>';
                extrasContainer.innerHTML += '<p><em>Check browser console for detailed metadata dump</em></p>';
            } else {
                console.log(`Successfully displayed extras data for ${foundExtras} objects`);
            }
        }

        // Initialize everything
        createScene().then(() => {
            engine.runRenderLoop(() => {
                if (scene) scene.render();
            });
        });

        window.addEventListener('resize', () => {
            engine.resize();
        });
    </script>
</body>
</html>
